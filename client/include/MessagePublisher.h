/* MessagePublisher.h (rename this later?) */ 
/* MessagePublisher.h handles all publishing of messages to server */

/* define structures of outgoing messages/packets */

// raw command/data ---> encrypt ---> encode ---> send data to server (in chunks?)

// NOTE: AES key will need to be shared via RSA key exchange or TLS handshake

// CipherText and Tag come from encryption
// IV is just some randomly generated bytes (12 bytes for aes-gcm)
// send Base64(IV + CipherText + Tag)



// RSA
/* NOTE: private key should only be on server
 * # Generate private key
 * openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048
 *
 * NOTE: public key should be embedded inside the implant
 * # Extract public key
 * openssl rsa -pubout -in private.pem -out public.pem
 *
 * NOTE: common approach is to just use one key pair
 */

/*
 * Load public key from PEM file
 */
EVP_PKEY* load_public_key(const char* filename) {
	FILE *fp = fopen(filename, "r");
	if (!fp) return NULL;

	EVP_PKEY *key = PEM_read_PUBKEY(fp, NULL, NULL, NULL);
	fclose(fp);
	return key;

}

/*
 * TODO: this func doesn't need to be in client? move to server
 * Load private key from PEM file  
 */
EVP_PKEY* load_private_key(const char* filename) {
	FILE *fp = fopen(filename, "r");
	if (!fp) return NULL;

	EVP_PKEY *key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
	fclose(fp);
	return key;
}

/**/
// createHeader() ?
